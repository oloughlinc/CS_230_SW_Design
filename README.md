# CS230 Final Project: Software Design Document

This document is a software design template that addresses basic language, architecture, and hardware recommendations for an application for a client called The Gaming Room. This client produces multiplayer gaming applications. In this scenario they are looking to expand one of their games, "Draw It or Lose It", to multiple platforms in order to reach more users.

# What did you do particularly well in developing this documentation?

The recommendations contained are the result of research into the specific needs of this client project and the most common and best practices for the application to be developed. I was particularly thorough in performing research to ensure that every recommendation is backed by resources and every recommendation is accurate.

# What about the process of working through a design document did you find helpful when developing the code?

Creating a design document frames the development to be performed and sets useful parameters and constraints for the next phase of the project. Further, it allows the project architect space in order to think through the design from the highest level before committing to a development path. This document therefore lays the groundwork for smooth and efficient development.

# If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?

As my knowledge in the field continues to grow, I would likely choose to revise the Recommendations sections. It could improve with more familiarity of the common tools and architectures used in other, similar projects that can come from personal experience.

# How did you interpret the user’s needs and implement them into your software design? Why is it so important to consider the user’s needs when designing?

A beautifully architected and crafted application that runs perfectly is worthless if it does not meet the needs of the users. The first step of creating this software design document was to consider the user's unique problem and define a set of needs and constraints based on that. Only after we understand the problem can we begin making recommendations about the solution.

# How did you approach designing software? What techniques or strategies would you use in the future to analyze and design a similar software application?

I wanted to first and foremost choose proven solutions that are common in the field. For many software problems it is not necessary to 're-invent the wheel', and instead focus on stability and performance through known sucessful tools and architectures. Not only does this improve long-term stability but also leads to more universal and easier to maintain software. In the future, a better analysis can come from gaining more experience in conjunction with the research performed. A better idea of when to use common methods or when to break the mold can come with time and experience.

